---
title: 普通联动
description: 定义字段联动关系，实现响应式数据流
---

## 概述

`defineReaction` 用于定义字段之间的联动关系。当依赖字段发生变化时，自动触发目标字段的更新逻辑。

## 基础用法

```ts
import { defineReaction } from '@signals-form/core'

const reaction = defineReaction({
  field: targetField,           // 目标字段
  dependencies: [sourceField],  // 依赖字段数组
  update: (handler, values) => {
    // 更新逻辑
    handler.setState('value', values[0])
  }
})
```

## API 参数

### 配置对象

| 参数 | 类型 | 必填 | 描述 |
|------|------|------|------|
| `field` | `Field\|string` | ✅ | 目标字段（被联动的字段） |
| `dependencies` | `(Field\|string)[]` | ✅ | 依赖字段数组（触发联动的字段） |
| `update` | `UpdateFunction` | ✅ | 联动更新函数 |
| `options` | `Options` | ❌ | 配置选项 |

### 选项配置 (options)

| 选项 | 类型 | 默认值 | 描述 |
|------|------|--------|------|
| `immediate` | `boolean` | `false` | 是否立即执行（初始化时就触发） |
| `once` | `boolean` | `false` | 是否只执行一次 |

### 更新函数

```ts
type UpdateFunction = (
  handler: FieldHandler,     // 目标字段的操作句柄
  values: any[],            // 依赖字段的值数组
) => void | Promise<any>
```

### 自动依赖收集

`defineReaction` 支持函数式调用，自动收集依赖并执行更新：

```ts
const reaction = defineReaction((handler) => {
  // 自动收集依赖
  const usernameHandler = handler.query('username')
  const password = handler.query('password').value

  // 基于依赖值执行逻辑
  if (password === 'admin') {
    usernameHandler.setState('value', username + '_admin')
  }
})
```

## 实际示例

### 基础联动

```ts title="用户名跟随密码变化"
const usernameReaction = defineReaction({
  field: username,
  dependencies: [password],
  update: (handler, [passwordValue]) => {
    if (passwordValue === 'admin') {
      handler.setState('value', 'administrator')
    }
  }
})
```

### 异步联动

```ts title="根据城市获取区域列表"
const districtReaction = defineReaction({
  field: district,
  dependencies: [city],
  update: async (handler, [cityId]) => {
    if (!cityId) return
    
    try {
      const districts = await fetchDistricts(cityId)
      handler.setState('options', districts)
      handler.setState('value', '') // 重置选中值
    } catch (error) {
      console.error('获取区域失败:', error)
    }
  }
})
```

### 多字段联动

```ts title="计算总价"
const totalReaction = defineReaction({
  field: total,
  dependencies: [price, quantity, discount],
  update: (handler, [price, quantity, discount]) => {
    const totalAmount = (price || 0) * (quantity || 0) * (1 - (discount || 0) / 100)
    handler.setState('value', Math.round(totalAmount * 100) / 100)
  },
  options: {
    immediate: true  // 初始化时就计算一次
  }
})
```

### 多对多联动

支持多个字段同时更新多个目标字段，但建议谨慎使用，优先考虑多对一的方式：

```ts title="多对多依赖更新"
const multiTargetReaction = defineReaction({
  field: [total1, total2],  // 多个目标字段
  dependencies: [price, quantity, discount],
  update: ([handler1, handler2], [price, quantity, discount]) => {
    const totalAmount = (price || 0) * (quantity || 0) * (1 - (discount || 0) / 100)
    const roundedTotal = Math.round(totalAmount * 100) / 100
    
    handler1.setState('value', roundedTotal)
    handler2.setState('value', roundedTotal)
  },
  options: {
    immediate: true
  }
})
```

> ⚠️ **注意**：尽量减少多对多的使用场景，推荐使用多对一的方式来实现联动逻辑，这样更容易维护和调试。

### 一次性联动

```ts title="初始化时从 URL 获取数据"
const initReaction = defineReaction({
  field: userId,
  dependencies: [urlParams],
  update: (handler, [params]) => {
    if (params?.userId) {
      handler.setState('value', params.userId)
    }
  },
  options: {
    once: true,       // 只执行一次
    immediate: true   // 立即执行
  }
})
```

## 高级特性


## 注意事项

1. **循环依赖**：系统支持循环依赖，但请确保不要在更新函数中修改 `value` 属性，否则会造成无限循环
4. **多对多联动**：尽量避免多对多的联动模式，优先使用多对一的方式
