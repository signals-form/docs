---
title: 普通联动
description: 定义字段联动关系，实现响应式数据流
---

## 概述

`defineReaction` 用于定义字段之间的联动关系。当依赖字段发生变化时，自动触发目标字段的更新逻辑。

## 基础用法

```ts
import { defineReaction } from '@signals-form/core'

const reaction = defineReaction({
  field: targetField,           // 目标字段
  dependencies: [sourceField],  // 依赖字段数组
  update: (handler, values) => {
    // 更新逻辑
    handler.setState('value', values[0])
  }
})
```

## API 参数

### 配置对象

| 参数 | 类型 | 必填 | 描述 |
|------|------|------|------|
| `field` | `Field\|string` | ✅ | 目标字段（被联动的字段） |
| `dependencies` | `(Field\|string)[]` | ✅ | 依赖字段数组（触发联动的字段） |
| `update` | `UpdateFunction` | ✅ | 联动更新函数 |
| `options` | `Options` | ❌ | 配置选项 |

### 选项配置 (options)

| 选项 | 类型 | 默认值 | 描述 |
|------|------|--------|------|
| `immediate` | `boolean` | `false` | 是否立即执行（初始化时就触发） |
| `once` | `boolean` | `false` | 是否只执行一次 |
| `dirtyIgnore` | `boolean` | `true` | 是否忽略脏值更新（跳过多次执行的优化） |

### 更新函数

```ts
type UpdateFunction = (
  handler: FieldHandler,     // 目标字段的操作句柄
  values: any[],            // 依赖字段的值数组
  abortSignal: AbortSignal  // 取消信号
) => void | Promise<any>
```

### 自动依赖收集

`defineReaction` 支持函数式调用，自动收集依赖并执行更新：

```ts
const reaction = defineReaction((handler) => {
  // 自动收集依赖
  const usernameHandler = handler.query('username')
  const password = handler.query('password').value

  // 基于依赖值执行逻辑
  if (password === 'admin') {
    usernameHandler.setState('value', username + '_admin')
  }
})
```

## 实际示例

### 基础联动

```ts title="用户名跟随密码变化"
const usernameReaction = defineReaction({
  field: username,
  dependencies: [password],
  update: (handler, [passwordValue]) => {
    if (passwordValue === 'admin') {
      handler.setState('value', 'administrator')
    }
  }
})
```

### 异步联动

```ts title="根据城市获取区域列表"
const districtReaction = defineReaction({
  field: district,
  dependencies: [city],
  update: async (handler, [cityId], abortSignal) => {
    if (!cityId) return
    
    try {
      const districts = await fetchDistricts(cityId, { signal: abortSignal })
      handler.setState('options', districts)
      handler.setState('value', '') // 重置选中值
    } catch (error) {
      if (!abortSignal?.aborted) {
        console.error('获取区域失败:', error)
      }
    }
  }
})
```

### 多字段联动

```ts title="计算总价"
const totalReaction = defineReaction({
  field: total,
  dependencies: [price, quantity, discount],
  update: (handler, [price, quantity, discount]) => {
    const totalAmount = (price || 0) * (quantity || 0) * (1 - (discount || 0) / 100)
    handler.setState('value', Math.round(totalAmount * 100) / 100)
  },
  options: {
    immediate: true  // 初始化时就计算一次
  }
})
```

### 多对多联动

支持多个字段同时更新多个目标字段，但建议谨慎使用，优先考虑多对一的方式：

```ts title="多对多依赖更新"
const multiTargetReaction = defineReaction({
  field: [total1, total2],  // 多个目标字段
  dependencies: [price, quantity, discount],
  update: ([handler1, handler2], [price, quantity, discount]) => {
    const totalAmount = (price || 0) * (quantity || 0) * (1 - (discount || 0) / 100)
    const roundedTotal = Math.round(totalAmount * 100) / 100
    
    handler1.setState('value', roundedTotal)
    handler2.setState('value', roundedTotal)
  },
  options: {
    immediate: true
  }
})
```

> ⚠️ **注意**：尽量减少多对多的使用场景，推荐使用多对一的方式来实现联动逻辑，这样更容易维护和调试。

### 一次性联动

```ts title="初始化时从 URL 获取数据"
const initReaction = defineReaction({
  field: userId,
  dependencies: [urlParams],
  update: (handler, [params]) => {
    if (params?.userId) {
      handler.setState('value', params.userId)
    }
  },
  options: {
    once: true,       // 只执行一次
    immediate: true   // 立即执行
  }
})
```

## 高级特性

### 脏值检查控制

默认情况下，为了优化性能，系统会跳过重复更新。使用 `dirtyIgnore` 可以跳过这个优化：

```ts
const cacheReaction = defineReaction({
  field: cache,
  dependencies: [input],
  update: (handler, [inputValue]) => {
    // 设置 dirtyIgnore: true 后，多次触发时，只有最后一次生效
    handler.setState('value', `cached_${inputValue}_${Date.now()}`)
  },
  options: {
    dirtyIgnore: true // 多次触发时，只有最后一次生效
  }
})
```

**工作原理：**
- `dirtyIgnore: true`（默认）：当多次执行时，会跳过前面的执行，只有最后一次执行会生效
- `dirtyIgnore: false`：当多次执行时，每次都会执行更新函数

### 取消异步操作

对于异步更新操作，系统会自动提供 AbortSignal 来取消过期的请求：

```ts
const searchReaction = defineReaction({
  field: searchResults,
  dependencies: [keyword],
  update: async (handler, [keyword], abortSignal) => {
    if (!keyword?.trim()) {
      handler.setState('value', [])
      return
    }

    // 监听取消信号
    abortSignal?.addEventListener('abort', () => {
      console.log('搜索请求被取消')
    })

    try {
      const results = await searchAPI(keyword, { signal: abortSignal })
      
      // 检查是否已被取消
      if (!abortSignal?.aborted) {
        handler.setState('value', results)
      }
    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error('搜索失败:', error)
      }
    }
  }
})
```

## 注意事项

1. **循环依赖**：系统支持循环依赖，但请确保不要在更新函数中修改 `value` 属性，否则会造成无限循环
2. **性能考虑**：默认的脏值检查有助于性能优化，除非必要（如需要基于时间戳等动态值更新），不建议设置 `dirtyIgnore: false`
3. **异步处理**：对于异步更新，务必处理 AbortSignal 以避免内存泄漏和竞态条件
4. **多对多联动**：尽量避免多对多的联动模式，优先使用多对一的方式

## 类型定义

```ts
export interface Reaction<
  T = any,
  P extends Props = Props,
  E extends string = string,
  D extends Dependencies = any,
> {
  /** 目标字段 */
  field: Dependency<T, P, E>;
  /** 依赖字段数组 */
  dependencies: [...D];
  /**
   * 更新函数，当依赖变化时被调用
   * @param handler - 字段操作句柄
   * @param depValues - 依赖字段的值数组
   * @param signal - 取消信号
   */
  update: (
    handler: FieldHandler<T, P>,
    depValues: GetDependencyValues<D>,
    signal: AbortSignal,
  ) => void | Promise<void | T> | T | Promise<T>;
  options?: {
    /** 是否只触发一次 */
    once?: boolean;
    /** 是否立即触发 */
    immediate?: boolean;
    /** 是否忽略脏值检查，跳过多次执行的值更新，默认为 false */
    dirtyIgnore?: boolean;
  };
}
```

普通联动为最基础的联动方式，适用于大多数场景。如需更高级的控制能力，请考虑使用 `defineRelation` 受控联动
