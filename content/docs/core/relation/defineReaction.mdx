---
title: Basic Reaction
description: Define field reaction relationships to implement reactive data flow
---

## Overview

`defineReaction` is used to define reaction relationships between fields. When dependency fields change, it automatically triggers the update logic of target fields.

## Basic Usage

```ts
import { defineReaction } from '@signals-form/core'

const reaction = defineReaction({
  field: targetField,           // Target field
  dependencies: [sourceField],  // Dependency field array
  update: (handler, values) => {
    // Update logic
    handler.setState('value', values[0])
  }
})
```

## API Parameters

### Configuration Object

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `field` | `Field\|string` | ✅ | Target field (field to be reacted) |
| `dependencies` | `(Field\|string)[]` | ✅ | Dependency field array (fields that trigger reactions) |
| `update` | `UpdateFunction` | ✅ | Reaction update function |
| `options` | `Options` | ❌ | Configuration options |

### Options Configuration

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `immediate` | `boolean` | `false` | Whether to execute immediately (trigger on initialization) |
| `once` | `boolean` | `false` | Whether to execute only once |
| `dirtyIgnore` | `boolean` | `true` | Whether to ignore dirty value updates (optimization to skip multiple executions) |

### Update Function

```ts
type UpdateFunction = (
  handler: FieldHandler,     // Operation handle for target field
  values: any[],            // Value array of dependency fields
  abortSignal: AbortSignal  // Abort signal
) => void | Promise<any>
```

### Automatic Dependency Collection

`defineReaction` supports functional calls with automatic dependency collection and execution:

```ts
const reaction = defineReaction((handler) => {
  // Automatically collect dependencies
  const usernameHandler = handler.query('username')
  const password = handler.query('password').value

  // Execute logic based on dependency values
  if (password === 'admin') {
    usernameHandler.setState('value', username + '_admin')
  }
})
```

## Practical Examples

### Basic Reaction

```ts title="Username follows password changes"
const usernameReaction = defineReaction({
  field: username,
  dependencies: [password],
  update: (handler, [passwordValue]) => {
    if (passwordValue === 'admin') {
      handler.setState('value', 'administrator')
    }
  }
})
```

### Async Reaction

```ts title="Get district list based on city"
const districtReaction = defineReaction({
  field: district,
  dependencies: [city],
  update: async (handler, [cityId], abortSignal) => {
    if (!cityId) return
    
    try {
      const districts = await fetchDistricts(cityId, { signal: abortSignal })
      handler.setState('options', districts)
      handler.setState('value', '') // Reset selected value
    } catch (error) {
      if (!abortSignal?.aborted) {
        console.error('Failed to fetch districts:', error)
      }
    }
  }
})
```

### Multi-field Reaction

```ts title="Calculate total price"
const totalReaction = defineReaction({
  field: total,
  dependencies: [price, quantity, discount],
  update: (handler, [price, quantity, discount]) => {
    const totalAmount = (price || 0) * (quantity || 0) * (1 - (discount || 0) / 100)
    handler.setState('value', Math.round(totalAmount * 100) / 100)
  },
  options: {
    immediate: true  // Calculate once on initialization
  }
})
```

### Many-to-Many Reaction

Supports multiple fields updating multiple target fields simultaneously, but use with caution - prefer many-to-one approach:

```ts title="Many-to-many dependency updates"
const multiTargetReaction = defineReaction({
  field: [total1, total2],  // Multiple target fields
  dependencies: [price, quantity, discount],
  update: ([handler1, handler2], [price, quantity, discount]) => {
    const totalAmount = (price || 0) * (quantity || 0) * (1 - (discount || 0) / 100)
    const roundedTotal = Math.round(totalAmount * 100) / 100
    
    handler1.setState('value', roundedTotal)
    handler2.setState('value', roundedTotal)
  },
  options: {
    immediate: true
  }
})
```

> ⚠️ **Note**: Try to minimize many-to-many usage scenarios. Prefer many-to-one approaches for reaction logic as they are easier to maintain and debug.

### One-time Reaction

```ts title="Initialize data from URL on startup"
const initReaction = defineReaction({
  field: userId,
  dependencies: [urlParams],
  update: (handler, [params]) => {
    if (params?.userId) {
      handler.setState('value', params.userId)
    }
  },
  options: {
    once: true,       // Execute only once
    immediate: true   // Execute immediately
  }
})
```

## Advanced Features

### Dirty Value Check Control

By default, the system skips redundant updates for performance optimization. Use `dirtyIgnore` to bypass this optimization:

```ts
const cacheReaction = defineReaction({
  field: cache,
  dependencies: [input],
  update: (handler, [inputValue]) => {
    // With dirtyIgnore: true, when triggered multiple times, only the last execution takes effect
    handler.setState('value', `cached_${inputValue}_${Date.now()}`)
  },
  options: {
    dirtyIgnore: true // When triggered multiple times, only the last execution takes effect
  }
})
```

**How it works:**
- `dirtyIgnore: true` (default): When executed multiple times, skips previous executions and only the last one takes effect
- `dirtyIgnore: false`: When executed multiple times, each execution runs the update function

### Canceling Async Operations

For async update operations, the system automatically provides AbortSignal to cancel outdated requests:

```ts
const searchReaction = defineReaction({
  field: searchResults,
  dependencies: [keyword],
  update: async (handler, [keyword], abortSignal) => {
    if (!keyword?.trim()) {
      handler.setState('value', [])
      return
    }

    // Listen for abort signal
    abortSignal?.addEventListener('abort', () => {
      console.log('Search request cancelled')
    })

    try {
      const results = await searchAPI(keyword, { signal: abortSignal })
      
      // Check if already cancelled
      if (!abortSignal?.aborted) {
        handler.setState('value', results)
      }
    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error('Search failed:', error)
      }
    }
  }
})
```

## Important Notes

1. **Circular Dependencies**: The system supports circular dependencies, but ensure you don't modify the `value` property in update functions, as this will cause infinite loops
2. **Performance Considerations**: Default dirty value checking helps with performance optimization. Unless necessary (e.g., updates based on timestamps or dynamic values), avoid setting `dirtyIgnore: false`
3. **Async Handling**: For async updates, always handle AbortSignal to avoid memory leaks and race conditions
4. **Many-to-Many Reactions**: Avoid many-to-many reaction patterns when possible. Prefer many-to-one approaches

## Type Definitions

```ts
export interface Reaction<
  T = any,
  P extends Props = Props,
  E extends string = string,
  D extends Dependencies = any,
> {
  /** Target field */
  field: Dependency<T, P, E>;
  /** Dependency field array */
  dependencies: [...D];
  /**
   * Update function called when dependencies change
   * @param handler - Field operation handle
   * @param depValues - Value array of dependency fields
   * @param signal - Abort signal
   */
  update: (
    handler: FieldHandler<T, P>,
    depValues: GetDependencyValues<D>,
    signal: AbortSignal,
  ) => void | Promise<void | T> | T | Promise<T>;
  options?: {
    /** Whether to trigger only once */
    once?: boolean;
    /** Whether to trigger immediately */
    immediate?: boolean;
    /** Whether to ignore dirty value checks, skip multiple execution value updates, default is true */
    dirtyIgnore?: boolean;
  };
}
```

Basic reactions are the most fundamental reaction type, suitable for most scenarios. For more advanced control capabilities, consider using `defineRelation` controlled reactions.
