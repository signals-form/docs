---
title: Controlled Relations
description: Define controlled relation relationships for interruptible linear execution
---

## Overview

`defineRelation` is used to define controlled relation relationships, solving the pain points of traditional field linking:

- ✅ **Linear Execution** - Avoids multiple redundant executions
- ✅ **Interruptible Updates** - Automatically cancels outdated async operations
- ✅ **Predictable Execution Order** - Executes in dependency order
- ✅ **Async Friendly** - Native support for Promise and AbortSignal

## Core Feature Comparison

| Feature | Regular Relations | Controlled Relations |
|---------|-------------------|----------------------|
| Execution Order | Uncertain | Linear execution |
| Duplicate Execution | Possible multiple times | Avoids duplicates |
| Async Interruption | Not supported | Auto-interrupt |
| Performance | Average | Excellent |

## Basic Usage

```ts
import { defineRelation } from '@signals-form/core'

const relation = defineRelation({
  field: targetField,           // Target field
  dependencies: [sourceField],  // Dependency fields
  update: (handler, values) => {
    // Update logic
    return values[0] + handler.value
  }
})
```

## API Parameters

### Configuration Object

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `field` | `Field` | ✅ | Target field (field being updated) |
| `dependencies` | `Field \| string[]` | ✅ | Dependency fields (fields that trigger updates) |
| `update` | `UpdateFunction` | ✅ | Relation update function |
| `options` | `Options` | ❌ | Configuration options |

### Options Configuration

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `isImmediate` | `boolean` | `false` | Whether to execute immediately (trigger on initialization) |
| `once` | `boolean` | `false` | Whether to execute only once |
| `dirtyIgnore` | `boolean` | `false` | Whether to ignore dirty value updates (always execute update) |

### Update Function

```ts
type UpdateFunction = (
  handler: FieldHandler,        // Target field operation handler
  values: any | any[],         // Dependency field values (single or array)
  abortSignal?: AbortSignal    // Cancellation signal
) => any | Promise<any>
```

## Linear Execution Mechanism

### Execution Order Guarantee

When field `a` changes, the relation execution order is: `a → c → d → e`

<Mermaid chart="graph LR
    A[a field changes] --> C[c field updates]
    A --> D[d field updates]
    C --> E[e field updates]
    D --> E"/>

```ts title="Linear Execution Example"
// a changes → c updates
defineRelation({
  field: c,
  dependencies: a,
  update: () => {
    return Math.floor(Math.random() * 100)
  }
})

// a changes → d updates (async)
defineRelation({
  field: d,
  dependencies: a,
  update: () => {
    return new Promise(resolve => {
      setTimeout(() => {
        resolve(String(Math.floor(Math.random() * 100)))
      }, 1000)
    })
  }
})

// c, d both change → e updates
defineRelation({
  field: e,
  dependencies: [c, d],
  update: (handler, [cValue, dValue]) => {
    const aValue = handler.query("***.a").value
    return `a: ${aValue}, c: ${cValue}, d: ${dValue}`
  }
})
```

### Avoiding Duplicate Execution

In regular relations, when `a` changes, `e` would be updated twice (because both `c` and `d` would trigger `e`).

In controlled relations, `e` is only executed once after all dependencies have completed their updates.

## Interruptible Execution

### Interruption Mechanism

When dependency fields change again, incomplete async updates are automatically interrupted:

```ts title="Interruption Example"
defineRelation({
  field: result,
  dependencies: searchInput,
  update: async (handler, [keyword], abortSignal) => {
    // Listen for interruption events
    abortSignal?.addEventListener("abort", () => {
      console.log("Search request was interrupted")
    })

    try {
      // Interruptible async request
      const response = await fetch(`/api/search?q=${keyword}`, {
        signal: abortSignal
      })
      
      if (abortSignal?.aborted) return
      
      const data = await response.json()
      return data.results
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('Request was cancelled')
      } else {
        console.error('Search failed:', error)
      }
    }
  }
})
```

### Interruption Scenarios

<Mermaid chart='sequenceDiagram
    participant User as User
    participant Field as Field
    participant Update as Update Function
    
    User->>Field: Input "abc"
    Field->>Update: Start async update
    Note over Update: Executing...
    User->>Field: Input "abcd"
    Field->>Update: Send interrupt signal
    Note over Update: Cancel previous update
    Field->>Update: Start new update'/>

## Practical Examples

### Basic Relation

```ts title="Username follows role changes"
const usernameRelation = defineRelation({
  field: username,
  dependencies: role,
  update: (handler, roleValue) => {
    if (roleValue === 'admin') {
      return 'administrator'
    }
    return `user_${Date.now()}`
  }
})
```

### Async Data Fetching

```ts title="Fetch districts based on city"
const districtRelation = defineRelation({
  field: district,
  dependencies: city,
  update: async (handler, cityId, abortSignal) => {
    if (!cityId) {
      handler.setState('options', [])
      return ''
    }

    try {
      const districts = await fetchDistricts(cityId, { 
        signal: abortSignal 
      })
      
      // Check if interrupted
      if (abortSignal?.aborted) return
      
      handler.setState('options', districts)
      return districts[0]?.value || ''
    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error('Failed to fetch districts:', error)
      }
    }
  }
})
```

### Multi-field Dependencies

```ts title="Price calculation"
const totalRelation = defineRelation({
  field: total,
  dependencies: [price, quantity, discount],
  update: (handler, [price, quantity, discount]) => {
    const subtotal = (price || 0) * (quantity || 0)
    const discountAmount = subtotal * ((discount || 0) / 100)
    return Math.round((subtotal - discountAmount) * 100) / 100
  },
  options: {
    isImmediate: true  // Calculate on initialization
  }
})
```

### Debounced Search

```ts title="Search with debounce"
const searchRelation = defineRelation({
  field: searchResults,
  dependencies: keyword,
  update: async (handler, keyword, abortSignal) => {
    if (!keyword?.trim()) {
      return []
    }

    // Debounce delay
    await new Promise(resolve => setTimeout(resolve, 300))
    
    if (abortSignal?.aborted) return

    try {
      const results = await searchAPI(keyword, { 
        signal: abortSignal 
      })
      return results
    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error('Search failed:', error)
        return []
      }
    }
  }
})
```

## Advanced Features

### Return Value Handling

```ts
defineRelation({
  field: targetField,
  dependencies: sourceField,
  update: (handler, value) => {
    // 1. Direct return value - automatically set to field.value
    return processedValue
    
    // 2. Return Promise - wait for async completion
    return Promise.resolve(asyncValue)
    
    // 3. Manual control - don't return value or return undefined
    handler.setState('value', customValue)
    handler.setState('disabled', true)
    // Don't return any value
  }
})
```

### Conditional Execution

```ts
defineRelation({
  field: conditionalField,
  dependencies: triggerField,
  update: (handler, value) => {
    // Conditional check
    if (!shouldUpdate(value)) {
      return // Don't execute update
    }
    
    return processValue(value)
  },
  options: {
    dirtyIgnore: true  // Ignore dirty value checks
  }
})
```

## Type Definitions

```ts
export interface Relation<
  T = any,
  P extends Props = Props,
  E extends string = string,
  D extends Dependencies = any,
> {
  /** The field being reacted to */
  field: Dependency<T, P, E>;
  /** The dependencies of the relation */
  dependencies: [...D];
  /**
   * The update function is called when the dependencies change.
   * It should return a value that will be used to update the field.
   * If the update function returns a promise, it will be awaited before updating the field.
   * @param handler - The field handler
   * @param depValues - The values of the dependencies
   * @param signal - The abort signal
   */
  update: (
    handler: FieldHandler<T, P>,
    depValues: GetDependencyValues<D>,
    signal: AbortSignal,
  ) => void | Promise<void | T> | T | Promise<T>;
  options?: {
    /** If true, the relation will only be triggered once */
    once?: boolean;
    /** If true, the relation will be triggered immediately */
    immediate?: boolean;
    /** If true, the relation will be allowed to skip updates multiple times, default is false */
    dirtyIgnore?: boolean;
    // support for debounce and throttle ?
  };
}
```

## Performance Optimization

1. **Reasonable Dependency Setting** - Only depend on fields that are truly needed
2. **Use AbortSignal** - Promptly cancel invalid async operations
3. **Avoid Circular Dependencies** - Check field dependency relationship graphs
4. **Appropriate Use of dirtyIgnore** - Ignore dirty value checks when needed

Controlled relations are a core feature of Signals Form, making complex field relationships simple
