---
title: 受控联动
description: 定义受控联动关系，实现可中断的线性执行
---

## 概述

`defineRelation` 用于定义受控联动关系，解决了传统联动的痛点：

- ✅ **线性执行** - 避免多次重复执行
- ✅ **可中断更新** - 自动取消过期的异步操作
- ✅ **执行顺序可预测** - 按依赖关系顺序执行
- ✅ **异步友好** - 原生支持 Promise 和 AbortSignal

## 核心特性对比

| 特性 | 普通联动 | 受控联动 |
|------|----------|----------|
| 执行顺序 | 不确定 | 线性执行 |
| 重复执行 | 可能多次 | 避免重复 |
| 异步中断 | 不支持 | 自动中断 |
| 性能 | 一般 | 优秀 |

## 基础用法

```ts
import { defineRelation } from '@signals-form/core'

const relation = defineRelation({
  field: targetField,           // 目标字段
  dependencies: [sourceField],  // 依赖字段
  update: (handler, values) => {
    // 更新逻辑
    return values[0] + handler.value
  }
})
```

## API 参数

### 配置对象

| 参数 | 类型 | 必填 | 描述 |
|------|------|------|------|
| `field` | `Field` | ✅ | 目标字段（被联动的字段） |
| `dependencies` | `Field \| string[]` | ✅ | 依赖字段（触发联动的字段） |
| `update` | `UpdateFunction` | ✅ | 联动更新函数 |
| `options` | `Options` | ❌ | 配置选项 |

### 选项配置 (options)

| 选项 | 类型 | 默认值 | 描述 |
|------|------|--------|------|
| `isImmediate` | `boolean` | `false` | 是否立即执行（初始化时就触发） |
| `once` | `boolean` | `false` | 是否只执行一次 |

### 更新函数

```ts
type UpdateFunction = (
  handler: FieldHandler,        // 目标字段的操作句柄
  values: any | any[],         // 依赖字段的值（单个或数组）
) => any | Promise<any>
```

## 线性执行机制

### 执行顺序保证

当 `a` 字段变化时，联动执行顺序为：`a → c → d → e`

<Mermaid chart="graph LR
    A[a 字段变化] --> C[c 字段更新]
    A --> D[d 字段更新]
    C --> E[e 字段更新]
    D --> E"/>

```ts title="线性执行示例"
// a 变化 → c 更新
defineRelation({
  field: c,
  dependencies: a,
  update: () => {
    return Math.floor(Math.random() * 100)
  }
})

// a 变化 → d 更新（异步）
defineRelation({
  field: d,
  dependencies: a,
  update: () => {
    return new Promise(resolve => {
      setTimeout(() => {
        resolve(String(Math.floor(Math.random() * 100)))
      }, 1000)
    })
  }
})

// c, d 都变化 → e 更新
defineRelation({
  field: e,
  dependencies: [c, d],
  update: (handler, [cValue, dValue]) => {
    const aValue = handler.query("***.a").value
    return `a: ${aValue}, c: ${cValue}, d: ${dValue}`
  }
})
```

### 避免重复执行

普通联动中，`a` 变化后 `e` 会被更新两次（因为 `c` 和 `d` 都会触发 `e`）。

受控联动中，`e` 只会在所有依赖更新完成后执行一次。

## 可中断执行

### 中断场景

<Mermaid chart='sequenceDiagram
    participant User as 用户
    participant Field as 字段
    participant Update as 更新函数
    
    User->>Field: 输入 "abc"
    Field->>Update: 开始异步更新
    Note over Update: 正在执行...
    User->>Field: 输入 "abcd"
    Field->>Update: 发送中断信号
    Note over Update: 取消前一次更新
    Field->>Update: 开始新的更新'/>


## 实际示例

### 基础联动

```ts title="用户名跟随角色变化"
const usernameRelation = defineRelation({
  field: username,
  dependencies: role,
  update: (handler, roleValue) => {
    if (roleValue === 'admin') {
      return 'administrator'
    }
    return `user_${Date.now()}`
  }
})
```

### 异步数据获取

```ts title="根据城市获取区域"
const districtRelation = defineRelation({
  field: district,
  dependencies: city,
  update: async (handler, cityId) => {
    if (!cityId) {
      handler.setState('options', [])
      return ''
    }

    try {
      const districts = await fetchDistricts(cityId)
      
      handler.setState('options', districts)
      return districts[0]?.value || ''
    } catch (error) {
        console.error('获取区域失败:', error)
    }
  }
})
```

### 多字段依赖

```ts title="价格计算"
const totalRelation = defineRelation({
  field: total,
  dependencies: [price, quantity, discount],
  update: (handler, [price, quantity, discount]) => {
    const subtotal = (price || 0) * (quantity || 0)
    const discountAmount = subtotal * ((discount || 0) / 100)
    return Math.round((subtotal - discountAmount) * 100) / 100
  },
})
```
## 高级特性

### 返回值处理

```ts
defineRelation({
  field: targetField,
  dependencies: sourceField,
  update: (handler, value) => {
    // 1. 直接返回值 - 自动设置到 field.value
    return processedValue
    
    // 2. 返回 Promise - 等待异步完成
    return Promise.resolve(asyncValue)
    
    // 3. 手动控制 - 不返回值或返回 undefined
    handler.setState('value', customValue)
    handler.setState('disabled', true)
    // 不返回任何值
  }
})
```

## 性能优化

1. **合理设置依赖** - 只依赖真正需要的字段
3. **避免循环依赖** - 检查字段依赖关系图

受控联动是 Signals Form 的核心特性，让复杂的字段关系变得简单可控！✨
