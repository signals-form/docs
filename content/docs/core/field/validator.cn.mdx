---
title: 校验器
description: 灵活强大的表单字段校验系统
---

## 概述

在复杂表单场景中，校验系统需要考虑多个维度：校验规则、校验时机、校验结果处理、校验逻辑组合、校验上下文、校验流程控制等。SignalForm 提供了完整的校验器解决方案，通过 `defineValidator` 来定义灵活的校验器。

## 校验模式

SignalForm 支持两种校验模式：

### 主动式校验 (Initiative)
用户主动触发字段值变更时触发的校验，适用于实时反馈场景。

### 被动式校验 (Passive)  
当依赖的其他字段发生变化时触发的校验，适用于字段间关联校验。

```ts
const password = defineField({
  id: "password",
  component: Input,
  props: { 
    label: "密码", 
    type: "password", 
    prefix: "🔒", 
    required: true 
  },
  validators: [
    // 主动式校验 - 用户输入时触发
    defineValidator()
      .initiative()
      .schema(z.string({ message: "请输入密码！" })
        .min(6, "密码至少6位")
        .max(20, "密码不能超过20位")),
        
    // 被动式校验 - 依赖其他字段变化触发  
    defineValidator()
      .passive()
      .schema(z.string({ message: "请输入密码！" })
        .min(6, "密码至少6位")
        .max(20, "密码不能超过20位"))
  ]
})
```

> 💡 **提示**：不指定模式时，默认为主动式校验。后续示例主要演示主动式校验，两种模式的 API 完全一致。

## 校验规则定义

### 基础用法

SignalForm 没有内置通用校验规则，而是提供了灵活的校验器范式，让你可以轻松集成各种校验引擎。以 Zod 为例：

```ts
// 单个校验器
defineField({
  id: "username",
  component: Input,
  validators: defineValidator()
    .schema(z.string({ message: "请输入用户名！" })
      .min(3, "用户名至少3位")
      .max(20, "用户名不能超过20位"))
})

// 多个校验器
defineField({
  id: "email", 
  component: Input,
  validators: [
    defineValidator()
      .schema(z.string({ message: "请输入邮箱！" })
        .email("请输入有效的邮箱格式"))
  ]
})
```

### 简化语法

当只有一个校验器且无其他配置时，可以直接使用 schema：

```ts
defineField({
  id: "phone",
  component: Input,
  validators: z.string({ message: "请输入手机号！" })
    .regex(/^1[3-9]\d{9}$/, "请输入有效的手机号")
})
```

## 校验时机控制

### updateOn - 事件触发控制

精确控制校验器在哪些事件触发时执行：

```ts
defineField({
  id: "password",
  component: Input,
  validators: [
    // 输入时进行格式校验
    defineValidator()
      .schema(z.string()
        .min(6, "密码至少6位")
        .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, "密码需包含大小写字母和数字"))
      .updateOn(['onChange'])
      .type('warning'),
      
    // 失焦时进行完整性校验
    defineValidator()
      .schema(z.string({ message: "密码不能为空" }))
      .updateOn(['onBlur'])  
      .type('error')
  ]
})
```

### should - 条件执行

通过决策函数控制校验器是否执行：

```ts
defineField({
  id: "confirmPassword",
  component: Input,
  validators: defineValidator()
    .schema(z.string())
    .should((ctx) => {
      // 仅当原密码已输入时才校验确认密码
      const password = ctx.query('password')?.value
      return Boolean(password)
    })
    .fact((value, query) => ({
      password: query('password')?.value,
      confirmPassword: value
    }))
    .custom((ctx) => {
      if (ctx.value.password !== ctx.value.confirmPassword) {
        return {
          message: "两次密码输入不一致",
          type: "error"
        }
      }
    })
})
```

> 📝 **说明**：`updateOn` 不存在时，默认为 `onChange` 事件触发校验。

## 校验结果类型

### 消息类型定义

通过 `type` 方法定义校验反馈的消息类型：

```ts
defineField({
  id: "username",
  component: Input,
  validators: [
    // 错误级别 - 阻止表单提交
    defineValidator()
      .schema(z.string({ message: "用户名不能为空" }))
      .type('error'),
      
    // 警告级别 - 不阻止提交但给出提示  
    defineValidator()
      .schema(z.string().min(8, "建议用户名至少8位以提高安全性"))
      .type('warning'),
      
    // 信息级别 - 友好提示
    defineValidator()
      .schema(z.string().max(20))
      .type('info')
      .custom((ctx) => ({
        message: `还可以输入 ${20 - ctx.value.length} 个字符`,
        type: 'info'
      }))
  ]
})
```

## 校验器组合

### 多校验器策略

使用数组方式注册多个校验器，应对不同场景：

```ts
defineField({
  id: "email",
  component: Input,
  validators: [
    // 必填校验
    defineValidator()
      .schema(z.string({ message: "邮箱不能为空" }))
      .updateOn(['onBlur'])
      .type('error'),
      
    // 格式校验  
    defineValidator()
      .schema(z.string().email("请输入有效的邮箱格式"))
      .updateOn(['onChange'])
      .type('warning'),
      
    // 异步唯一性校验
    defineValidator()
      .updateOn(['onBlur'])
      .debounce(500)
      .custom(async (ctx, abortSignal) => {
        const isUnique = await checkEmailUnique(ctx.value, { signal: abortSignal })
        if (!isUnique) {
          return {
            message: "该邮箱已被注册",
            type: "error"
          }
        }
      })
  ]
})
```

## 校验上下文

### fact - 数据预处理

构造校验所需的数据结构，支持跨字段校验：

```ts
defineField({
  id: "endDate",
  component: DatePicker,
  validators: defineValidator()
    .schema(z.object({
      startDate: z.date(),
      endDate: z.date(),
    }))
    .fact((value, query) => ({
      startDate: query('startDate')?.value,
      endDate: value
    }))
    .custom((ctx) => {
      const { startDate, endDate } = ctx.value
      if (startDate && endDate && endDate <= startDate) {
        return {
          message: "结束日期必须晚于开始日期",
          type: "error"
        }
      }
    })
})
```

### 复杂业务校验

```ts title="用户注册校验示例"
defineField({
  id: "username", 
  component: Input,
  validators: defineValidator()
    .fact((value, query, execDecision) => {
      const userType = query('userType')?.value
      const permissions = execDecision(D.use('userPermissions'))
      
      return {
        username: value,
        userType,
        permissions,
        minLength: userType === 'admin' ? 6 : 3
      }
    })
    .custom((ctx) => {
      const { username, userType, permissions, minLength } = ctx.value
      
      if (username.length < minLength) {
        return {
          message: `${userType === 'admin' ? '管理员' : '普通用户'}用户名至少${minLength}位`,
          type: 'error'
        }
      }
      
      if (userType === 'admin' && !permissions.canCreateAdmin) {
        return {
          message: "您无权创建管理员账户",
          type: 'error'
        }
      }
    })
})
```

## 校验流程控制

### break - 阻断后续校验

控制校验失败时是否继续执行后续校验器：

```ts
defineField({
  id: "password",
  component: Input,
  validators: [
    // 必填校验 - 失败时阻断后续校验
    defineValidator()
      .schema(z.string({ message: "密码不能为空" }))
      .type('error')
      .break(true), // error 类型默认为 true
      
    // 长度校验 - 失败时不阻断
    defineValidator()
      .schema(z.string().min(8, "密码建议至少8位"))
      .type('warning') 
      .break(false), // warning 类型默认为 false
      
    // 复杂度校验 - 只有前面都通过才执行
    defineValidator()
      .schema(z.string().regex(
        /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])/,
        "密码需包含大小写字母、数字和特殊字符"
      ))
      .type('info')
  ]
})
```

## 校验引擎

### 多引擎支持

在大型表单系统中支持多种校验引擎：

```ts
// 表单创建时注册校验引擎
const { app, form } = createForm({
  resolvers: {
    validator: {
      zod: zodResolver,      // Zod 引擎
      yup: yupResolver,      // Yup 引擎
      custom: customResolver // 自定义引擎
    }
  }
})

// 使用不同引擎的校验器
defineField({
  id: "data",
  component: Input,
  validators: [
    defineValidator()
      .schema(z.string())
      .engine('zod'),
      
    defineValidator()
      .schema(yup.string())
      .engine('yup'),
      
    defineValidator()
      .schema({ required: true, minLength: 3 })
      .engine('custom')
  ]
})
```

## 自定义校验器

### custom 方法

提供完全自定义的校验逻辑：

```ts
defineValidator()
  .updateOn(['onBlur'])
  .custom((ctx) => {
    const { value, query, execDecision, engine, updateOn } = ctx
    
    // 获取其他字段信息
    const relatedField = query('relatedField')?.value
    
    // 执行决策逻辑
    const hasPermission = execDecision(D.use('validatePermission'))
    
    // 自定义校验逻辑
    if (!hasPermission) {
      return {
        message: "您没有权限修改此字段",
        type: "error"
      }
    }
    
    if (value && relatedField && value === relatedField) {
      return {
        message: "此字段不能与相关字段相同",
        type: "warning"
      }
    }
  })
```

### 异步自定义校验

```ts title="异步唯一性检查"
defineValidator()
  .debounce(800)
  .custom(async (ctx, abortSignal) => {
    const { value } = ctx
    
    if (!value?.trim()) return
    
    // 监听取消信号
    abortSignal?.addEventListener('abort', () => {
      console.log('唯一性检查被取消')
    })
    
    try {
      const isUnique = await checkUsernameUnique(value, { 
        signal: abortSignal 
      })
      
      if (abortSignal?.aborted) return
      
      if (!isUnique) {
        return {
          message: "用户名已存在，请选择其他用户名",
          type: "error"
        }
      }
    } catch (error) {
      if (error.name !== 'AbortError') {
        return {
          message: "检查用户名时出现错误，请稍后重试",
          type: "error"
        }
      }
    }
  })
```

### Context 类型定义

```ts
interface ValidatorContext<T = any> {
  value: T | ValueRef<T>           // 当前字段值
  engine: string                   // 校验引擎名称
  execDecision: (decision: Decision) => boolean // 决策执行器
  query: (id: string) => FieldHandler | undefined // 字段查询器
  updateOn?: string               // 触发事件类型
}
```

## 防抖与竞态处理

### debounce 配置

处理频繁校验和异步竞态问题：

```ts
defineValidator()
  .debounce(1000, {
    edges: ['trailing'], // 默认为 ['trailing']
    signal: abortSignal  // 可选的取消信号
  })
  .updateOn(['onChange'])
  .custom(async (ctx, abortSignal) => {
    // 监听取消事件
    abortSignal?.addEventListener('abort', () => {
      console.log('校验被中止')
    })
    
    return new Promise((resolve) => {
      setTimeout(() => {
        if (!abortSignal?.aborted) {
          resolve({
            message: "异步校验完成",
            type: "info"
          })
        }
      }, 2000)
    })
  })
```

### edges 选项说明

```ts
// 仅在延迟结束时执行（默认）
.debounce(500, { edges: ['trailing'] })

// 仅在第一次调用时立即执行
.debounce(500, { edges: ['leading'] })

// 在开始和结束时都执行（需要至少两次调用）
.debounce(500, { edges: ['leading', 'trailing'] })
```

## 被动式校验特性

在被动式校验中，以下能力会自动变为响应式：

1. **fact 函数返回值**：自动收集依赖，响应式更新
2. **自定义校验器中的 value 和 query**：自动跟踪变化

```ts title="被动式校验示例"
defineField({
  id: "confirmPassword",
  component: Input,
  validators: defineValidator()
    .passive() // 被动式校验
    .fact((value, query) => ({
      password: query('password')?.value, // 响应式依赖
      confirmPassword: value
    }))
    .custom((ctx) => {
      // ctx.value 和 query 结果都是响应式的
      if (ctx.value.password !== ctx.value.confirmPassword) {
        return {
          message: "两次密码输入不一致",
          type: "error"
        }
      }
    })
})
```

## 最佳实践

### ✅ 推荐做法

1. **合理的校验时机**
   ```ts
   // 实时反馈用 onChange，完整性校验用 onBlur
   defineValidator()
     .updateOn(['onChange'])
     .type('warning') // 实时提示用 warning
   
   defineValidator()  
     .updateOn(['onBlur'])
     .type('error') // 严格校验用 error
   ```

2. **防抖异步校验**
   ```ts
   defineValidator()
     .debounce(500) // 避免频繁请求
     .custom(async (ctx, signal) => {
       // 处理 AbortSignal
     })
   ```

3. **清晰的校验层级**
   ```ts
   validators: [
     // 1. 必填校验
     defineValidator().schema(z.string()).type('error'),
     // 2. 格式校验  
     defineValidator().schema(z.string().email()).type('warning'),
     // 3. 业务校验
     defineValidator().custom(businessValidation).type('info')
   ]
   ```

### ❌ 避免的做法

1. **过于复杂的单个校验器**
2. **忽略异步校验的取消处理**
3. **过度使用 break(false)**

SignalForm 的校验器系统提供了完整而灵活的解决方案，能够应对各种复杂的表单校验场景！✨
