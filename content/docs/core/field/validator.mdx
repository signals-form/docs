---
title: Validators
description: Field validators
---

## validators
Previously we could use the simplest validators to provide feedback to users. In complex form scenarios, validation rules, validation timing (mechanisms), validation result handling, validation logic combination, validation context, validation flow control, multiple validator engine adaptation, developer experience, etc., are all things we need to consider when writing a validator.
- Use `defineValidator` to define validators.

## Validation Modes
- In SignalsForm, validation modes are divided into two types:
  - initiative (active validation): As the name suggests, it's validation triggered when users actively trigger field value changes.
  - passive (passive validation): Passive validation is generally used when validation depends on other field values. When other fields change, this validation will be triggered.
  - When not specified, it defaults to active validation.

```ts
const password = defineField({
  id: "password",
  component: Input,
  props: { label: "Password", type: "Password", prefix: "ðŸ”’", required: true },
  validators: [
          defineValidator()
               .initiative() // Active validator
               .schema(z.string({message: "Please enter password!"})
               .min(6, "Password must be at least 6 characters")
               .max(20, "Password cannot exceed 20 characters"))
               
        defineValidator()
               .passive() // Passive validator
               .schema(z.string({message: "Please enter password!"})
               .min(6, "Password must be at least 6 characters")
               .max(20, "Password cannot exceed 20 characters"))
  ]
})
```
- The following mainly explains active validation, because passive validation and active validation have consistent APIs

## Validation Rules

- SignalsForm does not directly integrate general validation rules, because in complex forms, these out-of-the-box rules are rarely used. Therefore, to avoid writing unnecessary validation logic code into the form framework, users need to define them themselves. Of course, SignalsForm internally implements validator paradigms that allow you to easily integrate various validation engines. We use "zod" as an example.
- `schema`: Define validation rules

```ts
defineField({
  id: "password",
  component: Input,
  validators: defineValidator()
                .schema(z.string({message: "Please enter password!"})
                .min(6, "Password must be at least 6 characters")
                .max(20, "Password cannot exceed 20 characters"))
})
// Can also be written like this
defineField({
  id: "password",
  component: Input,
  validators: [
      defineValidator()
         .schema(z.string({message: "Please enter password!"})
         .min(6, "Password must be at least 6 characters")
         .max(20, "Password cannot exceed 20 characters"))
  ]
})
```
When there's only one validator and no other configuration is needed, you can directly define its `schema` on `validators`.

```ts
defineField({
  id: "password",
  component: Input,
  validators: z.string({message: "Please enter password!"}).min(6, "Password must be at least 6 characters").max(20, "Password cannot exceed 20 characters")
})
```

## Validation Mechanism
- Validation timing may be essential in large forms. For example, in a field, there are events A and B, where only updates from event A need to be validated. We need to look at whether the validator is executed from the perspective of user interaction events. Additionally, what conditions must users meet to perform validation.
  - updateOn: This property defines when the current validation rule is triggered for validation due to what event causing updates.
  - should: This property is a decision information or a function. When executed and returns true, the current validator can take effect. Defaults to true.
  - Note: When updateOn doesn't exist, it defaults to triggering validation on the `onChange` event.

```ts
defineField({
  id: "password",
  component: Input,
  validators: defineValidator()
               .schema(z.string({message: "Please enter password!"})
               .min(6, "Password must be at least 6 characters")
               .max(20, "Password cannot exceed 20 characters"))
               .updateOn(['onChange'])
               .should(D.use('isA'))
})
```

## Validation Results
- SignalsForm converges feedback information generated by field validation into field information. So how do we determine the information type of the current validation parameters?
  - type: Use the `type` method to define the type of the current validator.

```ts
defineField({
  id: "password",
  component: Input,
  validators: defineValidator()
               .schema(z.string({message: "Please enter password!"})
               .min(6, "Password must be at least 6 characters")
               .max(20, "Password cannot exceed 20 characters"))
               .type('error')
})
```

## Validation Logic Combination
- In SignalsForm, validators have natural composition characteristics. We can register multiple validators to handle different scenarios.
- Use array method to register multiple validators

```ts
defineField({
  id: "password",
  component: Input,
  validators: [
          defineValidator()
               .schema(z.string({message: "Please enter password!"})
                       .min(6, "Password should be at least 6 characters")
                       .max(20, "Password should not exceed 20 characters"))
               .updateOn(['onChange'])
               .type('warning'),
           
           defineValidator()
               .schema(z.string({message: "Please enter password!"}))
               .updateOn(['onBlur'])
               .type('error'),
      ]
})
```

## Validation Context
- Validation context: Validation execution may depend on some other fields or user information, so before validation, we may need to construct the data structure that needs to be validated.
- fact: Function parameters are `value`, `queryState`, `execDecision`, helping you get other field information.
- In passive validation, it can serve as the dependency collection function for validators.

```ts
defineField({
  id: "password",
  component: Input,
  validators: defineValidator()
               .schema(z.object({
                  value: z.number({ message: "xxx" }),
                  name: z.string({ message : "xxx" })
                }))
               .fact(function(value, queryState, execDecision) {
                  return {
                      value,
                      name: queryState('username')?.value
                  }
            })
})
```

## Validation Flow Control
- Validation flow control: Flow control means whether to block subsequent validator execution when current validation fails.
  - break: Whether to block subsequent validation when validation fails. Defaults to true when type is error, others default to false.

```ts
defineField({
  id: "password",
  component: Input,
  validators: [
          defineValidator()
               .schema(z.string({message: "Please enter password!"})
                       .min(6, "Password should be at least 6 characters")
                       .max(20, "Password should not exceed 20 characters"))
               .updateOn(['onChange'])
               .break(false)
               .type('error'),
           
           defineValidator()
               .schema(z.string(z.string({message: "Please enter password!"}))
               .updateOn(['onBlur'])
               .type('error'),
      ]
})
```

## Validation Engine
- Multiple validator engine adaptation: In large form systems, the vast majority are custom validators. Therefore, it's necessary to support custom validators and engines.
  - engine: Define which engine executes the current validator. This value is the validation engine registered during form creation.

```ts
const { app, form } = createForm({
   resolvers: {
    validator: {
      ad: adResolver
    }
  },
})

[
  defineValidator()
     .schema(z.string({message: "Please enter password!"}))
     .updateOn(['onBlur'])
     .type('error'),
     .engine('ad')
]
```

## Custom Validators
- custom: A function with parameter ctx, return type is `{ messages: "xxx", type: "error" | "warning" | "info" }`.
- ctx type is:
```ts
{
  value: T | ValueRef<T>
  engine: string
  execDecision: (decision: Decision<string | BoolFn | Node>) => boolean
  query: (id: string) => Handler
  updateOn?: string
}
```

```ts
 defineValidator()
               .schema(z.string(z.string({message: "Please enter password!"}))
               .updateOn(['onBlur'])
               .custom((ctx)=>{
                   return {
                       messages: "Password doesn't meet requirements",
                       type: "error"
                   }
               }),
```

**Note:** Passive validation: Will make the value returned by the fact function reactive, and in custom validators, Value and query become reactive.

## Duplicate Validation and Race Condition Handling

- Duplicate validation & race conditions: When multiple validations occur, you can use `debounce`('/docs/core') to handle them.
  - The first parameter of the debounce function is the delay execution time in milliseconds, the second parameter is an options object.
    - signal (AbortSignal, optional): Optional AbortSignal object for canceling debounce function execution.
    - edges: An array specifying when the function should be called. Defaults to ['trailing'].
    - 'leading': If included, the function will execute immediately on the first call.
    - 'trailing': If included, the function will execute after debounceMs milliseconds from the last call.

If both 'leading' and 'trailing' are included, the function will be called at both the beginning and end of the delay period. However, the function must be called at least twice within debounceMs milliseconds for this to happen, because a single debounce function call cannot trigger the function twice.

- Supports automatic cancellation of previous validation execution when validation is triggered multiple times during asynchronous processes.

```ts
defineValidator()
      .debounce(1000)
      .updateOn(["onChange"])
      .custom(async (context, abortSignal) => {
        abortSignal.addEventListener("abort", () => {
          console.log("Age validation aborted");
        })
        return new Promise((resolve) => {
          setTimeout(() => {
            if (context.value) {}
            resolve({
              "": {
                message: Math.floor(Math.random() * 100).toFixed(),
                type: "error" as MessageType,
              }
            })
          }, 2000)
        })
      })
```
