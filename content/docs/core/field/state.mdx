---
title: Field State
description: Field state management
---

## Overview
- Field states are divided into two types: field value state and field metadata state.

## Handler Object
- `handler` provides a series of methods to operate field states, including getting current values, updating values, setting error messages, etc.

## Handler States

### Value States
- `value`: The value of the field
- `props`: The properties of the field
- `messages`: The error messages of the field

### Metadata States
#### Lifecycle State
- `isHidden`: Whether the field is hidden
- `isDisabled`: Whether the field is disabled
- `isValidating`: The validation state of the field
- `isValid`: Whether the field value is valid
- `isInitialized`: Whether the field has been initialized
- `isMounted`: Whether the field has been mounted
- `isDestroyed`: Whether the field has been destroyed

#### Field Meta State
- `isPristine`: Whether the field is in its initial state
- `isTouched`: Whether the field has been touched
- `isDirty`: Whether the field has been modified, even if restored to default value
- `isBlurred`: Whether the field has lost focus
- `isDefaultValue`: Whether the field is at its default value

![State Change Diagram](../../../img/field-state.jpeg)
State change diagram from Tanstack Form

#### Usage
- **Notice:** please do not deconstruct `metaState` which will cause the meta information state to lose its responsiveness unless you do not need the responsiveness.

```ts
const { metaState } = handler
const isDirty = metaState.isDirty // ✅ reactivity

const { isTouched, isPristine } = metaState // ❌ reactivity
```

## Handler Methods
- `query`: Query field state
- `setState`: Synchronously update field value or props
- `setAsyncState`: Asynchronously update field value or props
- `resetModel`: Reset field to initial value
- `cleanFieldErrors`: Clear field error messages
- `validate`: Validate field value
- `matchDecisions`: Create decision matcher
- `execDecision`: Execute decision
- `setFieldMessages`: Set field messages

## State Updates

- Metadata states are managed by the form system itself

- Value states are manually updated by users

### setState
- This method can synchronously update field value or props
- You can update field value through `handler.setState`

```ts
// events
const username = defineField({
  field: 'username',
  props: {
    placeholder: 'Please enter username',
  },
  events: {
    onChange() {
      this.setState('value', 'new value')
      this.setState('placeholder', 'new placeholder')
    }
  }
})

// defineRelation or defineReaction
const reaction = defineReaction({
  field: login.username,
  dependencies: login.password,
  update: (handler, passwordValue) => {
    handler.setState('value', 'new value')
    handler.setState('placeholder', 'new placeholder')
  },
})
```

### setAsyncState
- This method can asynchronously update field value or props
- You can update field value through `handler.setAsyncState`
- This method integrates interruptible asynchronous update capability

```ts
const username = defineField({
  field: 'username',
  props: {
    placeholder: 'Please enter username',
  },
})
.events({
    onChange(v) {
      this.setAsyncState('value', v)
      this.setAsyncState("label", (preValue, abortSignal) => {
        // abortSignal.abort() // Interrupt previous async operation
        return new Promise<string>((res) => {
          setTimeout(() => {
            res(v)
          }, 1000);
        })
      })
    }
  })

// defineRelation or defineReaction
const reaction = defineReaction({
  field: login.username,
  dependencies: login.password,
  update: (handler, passwordValue) => {
    handler.setAsyncState('value', ()=> 'new value')
    handler.setAsyncState('placeholder', ()=>'new placeholder')
  },
})
```
```ts
// events
const username = defineField({
  field: 'username',
  props: {
    placeholder: '请输入用户名',
  },
  events: {
    onChange() {
      this.setState('value', 'new value')
      this.setState('placeholder', 'new placeholder')
    }
  }
})

// defineRelation 或者 defineReaction
const reaction = defineReaction({
  field: login.username,
  dependencies: login.password,
  update: (handler, passwordValue) => {
    handler.setState('value', 'new value')
    handler.setState('placeholder', 'new placeholder')
  },
})
#### setAsyncState
- This method asynchronously updates the value or props of a field.
- In events, you can use `this.setAsyncState` to update the value of a field.
- In linkage processing, you can use `handler.setAsyncState` to update the value of a field.
- This method integrates the ability to interrupt asynchronous updates.
- 此方法，集成了可中断的异步更新的能力
```ts
const username = defineField({
  field: 'username',
  props: {
    placeholder: '请输入用户名',
  },
})
.events({
    onChange(v) {
      this.setAsyncState('value', v)
      this.setAsyncState("label", (preValue, abortSignal) => {
        // abortSignal.abort() // 中断上次的异步操作
        return new Promise<string>((res) => {
          setTimeout(() => {
            res(v)
          }, 1000);
        })
      })
    }
  })

// defineRelation 或者 defineReaction
const reaction = defineReaction({
  field: login.username,
  dependencies: login.password,
  update: (handler, passwordValue) => {
    handler.setAsyncState('value', ()=> 'new value')
    handler.setAsyncState('placeholder', ()=>'new placeholder')
  },
})
```

### messages
To solve the limitations of traditional form message handling, where each message type needs to be implemented and maintained separately, and messages may conflict with each other, such as complex handling when a field has both errors and warnings at the same time, in modern complex form scenarios, a field may have multiple states and feedback simultaneously.<br/>
SignalsForm converges this type of feedback text into `messages`, which has the benefit of avoiding writing duplicate code when handling different types of messages, hiding the internal implementation details of the message system from the outside, providing a unified interface, and making it easier to add new message types such as "Success" or custom types. The design of `messages` aims to provide a more flexible and extensible message handling mechanism, supporting the coexistence of multiple message types and states.
- Common message types include: `error`, `warning`, `info`, etc. These types of information are generally closely connected to field validators.
- Additionally, we can set feedback information ourselves, using `handler.setFieldMessages` or `handler.cleanFieldErrors` to update field information, but it's not recommended to set `error`, `warning` and similar information manually

```ts
const username = defineField({
  field: 'username',
  props: {
    placeholder: 'Please enter username',
  },
  events: {
    onChange() {
      this.setFieldMessages({ message: 'Username cannot be empty', type: 'error' })
    }
  }
})

// defineRelation or defineReaction
const reaction = defineReaction({
  field: login.username,
  dependencies: login.password,
  update: (handler, passwordValue) => {
    handler.setFieldMessages({ message: 'Password cannot be empty', type: 'error' })
  },
})
```
